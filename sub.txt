0:00:23.000,0:00:28.460
ок добрый вечер давайте начинать по

0:00:26.840,0:00:33.340
традиции навещать не могу когда-нибудь

0:00:28.460,0:00:33.340
учат есть картинка и звук и мы начнем

0:00:53.910,0:01:01.010
спасибо значит еще есть такое

0:00:58.260,0:01:03.330
предложение что после сейчас будет

0:01:01.010,0:01:08.729
видимо два куска

0:01:03.330,0:01:12.600
два куска с перерывом лет после второй

0:01:08.729,0:01:16.590
лекции я зайду в discord ссылка будет

0:01:12.600,0:01:18.180
телеграме сколько вот они-то и если есть

0:01:16.590,0:01:21.090
какие-то организационные вопросы по

0:01:18.180,0:01:24.150
поводу там сколько лап как будет

0:01:21.090,0:01:27.030
проходить экзамен то я уже после лекций

0:01:24.150,0:01:28.800
дискорд начать вопросы отвечу насчет

0:01:27.030,0:01:31.890
курс называется технологии

0:01:28.800,0:01:35.580
программирования и он посвящен языку

0:01:31.890,0:01:41.250
джалла курс состоит из двух частей в

0:01:35.580,0:01:47.960
первой части мы собственно то чтобы дел

0:01:41.250,0:01:52.970
час это будет поведение в язык java и

0:01:47.960,0:01:56.840
разберем просто все основные концепции

0:01:52.970,0:02:01.170
после этого участи круг летом будет

0:01:56.840,0:02:02.729
производственная практика на java там

0:02:01.170,0:02:05.780
будем сейчас как царь графические

0:02:02.729,0:02:08.940
приложения вообще она дала в частности и

0:02:05.780,0:02:13.800
собственно на 3 курсе будет продолжать

0:02:08.940,0:02:16.709
фланге программирования 2 тайм это

0:02:13.800,0:02:17.970
становится как с помощью java писать

0:02:16.709,0:02:25.310
свои сетевые программы

0:02:17.970,0:02:25.310
это могут быть как игры которые

0:02:26.209,0:02:31.230
многопользовательские так и сайт и мы

0:02:28.739,0:02:33.930
рассмотрим это и другое сегодня хочется

0:02:31.230,0:02:38.459
поговорить о двух вещах первое открытие

0:02:33.930,0:02:40.170
всего поговорить о том вообще истории

0:02:38.459,0:02:41.910
джалла почему она появилась почему она

0:02:40.170,0:02:44.190
стала популярна в чем особенность языка

0:02:41.910,0:02:47.930
и второе поговорить про базовый

0:02:44.190,0:02:50.610
синтаксис типы данных

0:02:47.930,0:02:54.900
основные инструкции на виду операторы

0:02:50.610,0:02:56.340
языка там циклы iv есть предварительные

0:02:54.900,0:02:58.890
требования курса что вы умеете

0:02:56.340,0:03:00.750
программировать на сессию плюс плюс вот

0:02:58.890,0:03:02.400
собственно поэтому многие концепции

0:03:00.750,0:03:04.109
например объектно-ориентированное

0:03:02.400,0:03:07.849
программирование будет рассказываться не

0:03:04.109,0:03:10.079
с нуля ну и там трусом этом циклы и

0:03:07.849,0:03:12.420
проверки мудро казани с нуля

0:03:10.079,0:03:15.000
а предполагается что вы это вы знаете я

0:03:12.420,0:03:18.150
просто расскажу какие есть

0:03:15.000,0:03:21.319
принципиальные отличия , а эти

0:03:18.150,0:03:26.720
конструкции и почему они появились

0:03:21.319,0:03:26.720
давайте начинать значит собственно

0:03:30.410,0:03:37.620
исторически все до семидесятые годы си

0:03:34.290,0:03:40.769
плюс плюс восьмидесятые годы java

0:03:37.620,0:03:48.510
это 90-е годы но там по моему девяносто

0:03:40.769,0:03:51.750
пятый год появилось вопрос про практику

0:03:48.510,0:03:57.239
я все расскажу в дискорде после оплаты

0:03:51.750,0:04:01.459
лекции джавадов пятый год собственно и

0:03:57.239,0:04:01.459
так корпорация такая была сам

0:04:02.000,0:04:05.870
данный момент кооперацией сам купила

0:04:04.850,0:04:10.240
корпорации oracle

0:04:05.870,0:04:14.480
я собственно вот дрова занимается

0:04:10.240,0:04:19.390
развитием фирмы oracal кроме того есть

0:04:14.480,0:04:24.820
комьюнити то есть до развивается как

0:04:19.390,0:04:29.120
открытый проект то есть есть комитет где

0:04:24.820,0:04:30.440
заседают представители как сообщество

0:04:29.120,0:04:34.250
программистов так разных фирм

0:04:30.440,0:04:37.250
разработчиков этих инструментов для java

0:04:34.250,0:04:39.320
и вот они занимаются развитием языка

0:04:37.250,0:04:42.680
тельств предлагают новые возможности

0:04:39.320,0:04:46.940
обсуждают и собственно это уже

0:04:42.680,0:04:50.270
развивается язык собственно следующий

0:04:46.940,0:04:52.190
виток развития это язык си sharp от

0:04:50.270,0:04:54.830
microsoft это тот уже двухтысячные годы

0:04:52.190,0:04:57.620
в принципе поняла пару слов скажу потому

0:04:54.830,0:05:00.830
что это язык идеологический близкий то

0:04:57.620,0:05:04.460
есть если вы освоите один из них то на

0:05:00.830,0:05:07.790
другой перейти будет легче потому что в

0:05:04.460,0:05:15.979
обоих этих языках важно лежат одни и те

0:05:07.790,0:05:16.729
же идеи вообще как как исторически все

0:05:15.979,0:05:22.220
складывалось

0:05:16.729,0:05:28.060
но если помним ся то усе был слот он

0:05:22.220,0:05:30.560
такой writeline войскам подрывая то есть

0:05:28.060,0:05:32.720
предполагалось что программистом не

0:05:30.560,0:05:36.590
должен знать особенности офицеры

0:05:32.720,0:05:39.190
конкретного компьютера то есть какие

0:05:36.590,0:05:43.460
регистры какие команды есть у процессора

0:05:39.190,0:05:46.340
себя компилятор и собственно если нужно

0:05:43.460,0:05:48.910
перейти на другой компьютер не требуется

0:05:46.340,0:05:50.560
переписывать программу а надо просто

0:05:48.910,0:05:52.640
взять

0:05:50.560,0:05:54.940
текущие исходный код и просто

0:05:52.640,0:05:59.120
перекомпилировать его друг компилятором

0:05:54.940,0:06:02.620
под новый компьютер вот но при этом

0:05:59.120,0:06:05.360
нельзя взять скажем уже исполняемый код

0:06:02.620,0:06:07.750
с одного компьютера скажем с mako и

0:06:05.360,0:06:11.380
запустить например на из 80

0:06:07.750,0:06:12.130
эти потому что ну вот сейчас уже на

0:06:11.380,0:06:16.480
магия

0:06:12.130,0:06:16.930
процессора и система команда друга кроме

0:06:16.480,0:06:19.780
того

0:06:16.930,0:06:22.300
вообще тут лучше говорить и не столько о

0:06:19.780,0:06:24.820
конкретном процессоре сколько вести

0:06:22.300,0:06:26.070
понятия платформы под платформу в этом

0:06:24.820,0:06:30.390
курсе будем понимать

0:06:26.070,0:06:34.630
комбинацию между операционной системой и

0:06:30.390,0:06:36.940
процессором потому что как только вы

0:06:34.630,0:06:38.950
начинаете писать более менее сложные

0:06:36.940,0:06:45.850
программы разных потребоваться

0:06:38.950,0:06:47.290
операционная система там например нужно

0:06:45.850,0:06:48.910
работать с файлами через операционную

0:06:47.290,0:06:50.490
систему нужно рисовать графические

0:06:48.910,0:06:52.780
окошке

0:06:50.490,0:06:56.890
все это разных персон с тем только по

0:06:52.780,0:06:59.290
разному делается кроме того стандарт

0:06:56.890,0:07:00.040
языка си си плюс плюс графической блеать

0:06:59.290,0:07:02.580
эко не входят

0:07:00.040,0:07:05.669
под каждой местности надо писать свою

0:07:02.580,0:07:08.230
кроме того разных операционных системах

0:07:05.669,0:07:09.160
разные форматы исполняемых файлов то

0:07:08.230,0:07:11.500
есть формат файла

0:07:09.160,0:07:15.750
несмотря на то что и там и там

0:07:11.500,0:07:19.000
содержится например и windows

0:07:15.750,0:07:21.990
ставим файлик команды для процессора 86

0:07:19.000,0:07:25.240
формат файлов разный

0:07:21.990,0:07:28.000
эль файл который получен компиляции

0:07:25.240,0:07:30.880
программы на си климаксе перенести его

0:07:28.000,0:07:32.950
windows там запустить вот все равно тебя

0:07:30.880,0:07:34.600
требуется шаг взять исходные коды

0:07:32.950,0:07:38.800
программы на языке си и

0:07:34.600,0:07:40.900
перекомпилировать компилятором подвид ты

0:07:38.800,0:07:43.620
хочешь программами разных платформах но

0:07:40.900,0:07:45.970
опять же ты столкнешься с массой проблем

0:07:43.620,0:07:48.010
проблем с все будет связано с тем что

0:07:45.970,0:07:50.050
под linux писал графическое приложение

0:07:48.010,0:07:57.660
должен был выбрать какую-то библиотеку

0:07:50.050,0:08:00.460
например биотек у детей под windows

0:07:57.660,0:08:02.640
обычно графические приложения пишут на

0:08:00.460,0:08:05.380
торги nforce это стандартная библиотека

0:08:02.640,0:08:07.030
графический интерфейс под windows тем

0:08:05.380,0:08:10.390
как минимум эту часть программы

0:08:07.030,0:08:12.850
переписать поэтому в принципе вот это

0:08:10.390,0:08:13.740
вот идея пройду once компания

0:08:12.850,0:08:17.910
она

0:08:13.740,0:08:20.430
работа только для программе с некоторыми

0:08:17.910,0:08:21.979
ограничениями то есть программы не

0:08:20.430,0:08:24.120
должно быть работой сессию

0:08:21.979,0:08:26.220
программы должна быть графического

0:08:24.120,0:08:27.900
интерфейса если что-то такое пыль с тебя

0:08:26.220,0:08:31.949
сразу нужно под разной операционной

0:08:27.900,0:08:34.050
системы учитывать эти нюансы и

0:08:31.949,0:08:36.360
переписывать сок программе с учетом

0:08:34.050,0:08:40.050
операционной системы да там были всякие

0:08:36.360,0:08:42.659
решения эти библиотеки каюте которая

0:08:40.050,0:08:44.459
пыталась взять на себя эту работу но это

0:08:42.659,0:08:47.490
все равно не часть стандарта это нужно

0:08:44.459,0:08:51.029
отдельно такое скачивать бразилиа те как

0:08:47.490,0:08:53.670
с ними федерации так далее какую задачу

0:08:51.029,0:08:56.100
решали начала первых словом к слову у

0:08:53.670,0:08:58.649
них был компаньон сраного и боя что

0:08:56.100,0:09:02.100
значит программа компилируется один раз

0:08:58.649,0:09:06.390
и под скомпилированный код можно

0:09:02.100,0:09:09.690
запускать на разных платформах идея

0:09:06.390,0:09:13.200
более амбициозное не требуется

0:09:09.690,0:09:15.330
перекомпиляции я просто двоичный код

0:09:13.200,0:09:18.690
устроят таким образом можно списать и

0:09:15.330,0:09:21.959
windows и на linux и в майке и так далее

0:09:18.690,0:09:24.450
вот мы поговорим так это устроено как

0:09:21.959,0:09:26.810
вообще исторически они дошли до этой

0:09:24.450,0:09:26.810
задачи

0:09:28.040,0:09:33.570
если тебе в то время требовалось

0:09:31.430,0:09:35.100
полярная программа я хотела что

0:09:33.570,0:09:37.440
пользователи могли запускать ее на

0:09:35.100,0:09:38.310
компьютерах от с разными платформами то

0:09:37.440,0:09:42.190
есть там

0:09:38.310,0:09:45.790
windows linux макс должен был у себя на

0:09:42.190,0:09:48.120
сайте положить три версии программы то

0:09:45.790,0:09:51.550
есть три исполняемые файлы

0:09:48.120,0:09:56.530
скомпилированные под разные операционные

0:09:51.550,0:09:58.240
системы с толку на си плюс плюс сам

0:09:56.530,0:10:00.790
хотел решить такую задачу вот нельзя ли

0:09:58.240,0:10:02.710
сделать так нельзя ли как-то сделать

0:10:00.790,0:10:06.220
такую программу чтобы я положил на сайты

0:10:02.710,0:10:09.130
и ладно не важно откуда пользователь

0:10:06.220,0:10:11.440
было скачал с компьютером с linux

0:10:09.130,0:10:13.120
смотрели свин он запустилось и эта

0:10:11.440,0:10:15.790
программа программ программ была в одном

0:10:13.120,0:10:18.340
экземпляре ты технологию которое они

0:10:15.790,0:10:23.410
пытались сделать называлась java апплет

0:10:18.340,0:10:25.120
ой это такие программы которые написаны

0:10:23.410,0:10:26.340
были на java и выполнялись внутри

0:10:25.120,0:10:31.020
браузера

0:10:26.340,0:10:35.580
вот ну да наши дни на чалонге не дожила

0:10:31.020,0:10:38.050
сначала она была вытеснена технологии

0:10:35.580,0:10:40.570
macromedia flash до сих пор вы можете

0:10:38.050,0:10:44.610
там где-то моете браузерные игры на

0:10:40.570,0:10:46.900
чалонге flash вот 1 верста мне тебя были

0:10:44.610,0:10:48.910
видео стриминга бы на чалонге flash

0:10:46.900,0:10:51.550
сейчас человека flash тоже умерла и и

0:10:48.910,0:10:52.710
собственно если что-то нужно выполнить

0:10:51.550,0:10:57.790
внутри браузера

0:10:52.710,0:11:00.750
это язык java script вот это есть в

0:10:57.790,0:11:03.790
принципе то ради чего изначально

0:11:00.750,0:11:09.520
затевалось это сейчас не используется но

0:11:03.790,0:11:11.500
язык java script он язык специальные он

0:11:09.520,0:11:14.200
направляющим похож мы про него будем

0:11:11.500,0:11:16.030
говорить следующем семестре я просто

0:11:14.200,0:11:18.040
тогда когда разрабатывали язык java

0:11:16.030,0:11:20.320
script зал был очень популярным в

0:11:18.040,0:11:22.150
маркетинговых целях решили как бы

0:11:20.320,0:11:24.130
частичку популярности частичку хайпа

0:11:22.150,0:11:25.750
взять себе и вот названия язык с более

0:11:24.130,0:11:27.110
слова джалла но в принципе java script и

0:11:25.750,0:11:32.230
giovanni очень похоже тараз

0:11:27.110,0:11:34.730
языки и еще раз когда разрабатывали того

0:11:32.230,0:11:37.940
хотели решить зачем кроссплатформенность

0:11:34.730,0:11:40.310
и то есть чтобы 1 этаже исполняемый год

0:11:37.940,0:11:43.070
запускался на разных платформах

0:11:40.310,0:11:44.839
то по форме мы понимаем данном курсе

0:11:43.070,0:11:49.760
комбинацию с процессор операционной

0:11:44.839,0:11:50.810
системы но в результате вот это

0:11:49.760,0:11:55.760
технологии рать которой всё

0:11:50.810,0:11:58.010
разрабатывалась она умерла но java

0:11:55.760,0:12:00.769
является очень популярным языком

0:11:58.010,0:12:01.579
его использовать для широкого набора

0:12:00.769,0:12:06.740
предложений

0:12:01.579,0:12:09.880
то есть используют как для в описании то

0:12:06.740,0:12:13.970
что называется десктопных программ

0:12:09.880,0:12:15.920
который вашем компьютере например можно

0:12:13.970,0:12:19.959
что указать среда разработки intel джея

0:12:15.920,0:12:19.959
идея и clips and bells

0:12:20.260,0:12:23.540
сила им это все программу написанное на

0:12:23.000,0:12:26.570
java

0:12:23.540,0:12:29.899
есть даже играя написанная на java ну

0:12:26.570,0:12:33.350
собственно это майкрофт ну кроме того

0:12:29.899,0:12:35.600
большое количество серверного кода то

0:12:33.350,0:12:39.560
есть для системных приложений написано

0:12:35.600,0:12:44.140
да вот мы сейчас постепенно разберемся в

0:12:39.560,0:12:44.140
чем люди почему-то стало популярным

0:12:44.829,0:12:55.310
значит что придумали ну нельзя сказать

0:12:52.070,0:12:57.260
что они первые придумали на самом деле

0:12:55.310,0:13:00.190
вот идея по которой рассказал там чили

0:12:57.260,0:13:02.810
них pascal первый раз появилась просто и

0:13:00.190,0:13:06.290
удалось это просто как-то очень удачно

0:13:02.810,0:13:08.060
сделать и реализовать удачное хорошо

0:13:06.290,0:13:14.110
маркетом провести в общем в нужное время

0:13:08.060,0:13:16.399
их решения стало популярным теперь между

0:13:14.110,0:13:19.970
программой и непосредственно процессом

0:13:16.399,0:13:22.730
есть прослойка называется виртуальная

0:13:19.970,0:13:25.290
машина java по сути это программная

0:13:22.730,0:13:28.089
модель концу

0:13:25.290,0:13:31.089
внутри которой исполняется программа ну

0:13:28.089,0:13:33.959
вот у вас наверно был курс посвященной

0:13:31.089,0:13:36.459
архитектуре компьютера и дар был

0:13:33.959,0:13:39.879
симулятор компьютера там какого то там

0:13:36.459,0:13:42.160
то левак стали дек черт то кого то есть

0:13:39.879,0:13:44.139
это программная модель и какого-то

0:13:42.160,0:13:44.769
компьютера там например если нужно

0:13:44.139,0:13:47.860
регистр

0:13:44.769,0:13:49.600
это массе массивы датами набор регистров

0:13:47.860,0:13:50.889
это воды программного массивов и

0:13:49.600,0:13:53.529
получается что ваша программа

0:13:50.889,0:13:56.199
исполняется не на процессоре а

0:13:53.529,0:14:00.459
исполняется внутри вот этого симулятора

0:13:56.199,0:14:04.089
процессора точно такую же роль играет

0:14:00.459,0:14:07.179
java машины то есть это программная

0:14:04.089,0:14:12.839
модель компьютера собственно и

0:14:07.179,0:14:15.819
компилятор теперь порождает код не для

0:14:12.839,0:14:17.619
непосредственно процессора порождает код

0:14:15.819,0:14:21.069
для этой вот виртуальной машины для

0:14:17.619,0:14:22.980
этого симулятора компьютера то есть для

0:14:21.069,0:14:27.429
каждой новой платформы

0:14:22.980,0:14:32.230
требуется теперь написать новую машину

0:14:27.429,0:14:34.120
ну байт-код несложный виртуальная машина

0:14:32.230,0:14:39.329
обычно достаточно простая почему кстати

0:14:34.120,0:14:42.160
называется байт-код потому что в

0:14:39.329,0:14:45.639
двоичных кодах для этой машины все

0:14:42.160,0:14:48.779
команды умещается ровно в 10 да вот

0:14:45.639,0:14:53.559
поэтому вот если например там у

0:14:48.779,0:14:54.339
компьютера фирмы intel там команды 4

0:14:53.559,0:14:57.639
байт не

0:14:54.339,0:15:02.620
или бывает 6 байт не переменная длина то

0:14:57.639,0:15:06.870
у команды не очень много и они

0:15:02.620,0:15:10.509
однобайтовых то есть принципе написать

0:15:06.870,0:15:12.549
новую дала машину для новой платформы

0:15:10.509,0:15:13.959
для процессора кормили для процессорами

0:15:12.549,0:15:17.519
и которые дали для телефона

0:15:13.959,0:15:20.529
это принципе не очень сложная задача

0:15:17.519,0:15:21.629
компилятор ты бежишь один раз компилятор

0:15:20.529,0:15:25.360
генерирует

0:15:21.629,0:15:28.329
инструкции генералов двоичный код

0:15:25.360,0:15:30.879
но не скандар конкретного процессора а в

0:15:28.329,0:15:32.190
виде кода для вот этой вот придуманный

0:15:30.879,0:15:35.760
машины виртуальный наш

0:15:32.190,0:15:39.440
нажала и уже задачи виртуальной машины

0:15:35.760,0:15:45.210
java во время выполнения программы

0:15:39.440,0:15:50.570
перевести инструкции байт-кода cod

0:15:45.210,0:15:53.460
реального процессора то есть по сути

0:15:50.570,0:15:55.070
если у нас вот программы россии моё

0:15:53.460,0:15:59.790
дрожали в двоичный код

0:15:55.070,0:16:03.060
запустили и процессор идет инструкция за

0:15:59.790,0:16:04.470
инструкция их выполняет то у нас бы было

0:16:03.060,0:16:07.310
программа на java

0:16:04.470,0:16:09.510
мы из компилировали получили байт-код

0:16:07.310,0:16:10.550
теперь мы должны допустить виртуальную

0:16:09.510,0:16:14.720
машину

0:16:10.550,0:16:18.360
скормить на вход виртуальной машине свой

0:16:14.720,0:16:19.890
байт-код виртуальная машина считывает из

0:16:18.360,0:16:23.760
файла из байт кодом инструкция за

0:16:19.890,0:16:27.720
инструкций каждую инструкцию преобразует

0:16:23.760,0:16:30.120
в инструкцию уже настоящего процессора и

0:16:27.720,0:16:31.950
выполняет если у настоящей программы на

0:16:30.120,0:16:37.200
каждую функцию один шаг просто выполнить

0:16:31.950,0:16:42.260
то в джаве на каждую инструкцию два шага

0:16:37.200,0:16:45.210
1 1 шаг транслировать с байт-кода в

0:16:42.260,0:16:48.150
нативный так называемый код то есть на

0:16:45.210,0:16:50.190
эти слова родной в код непосредственно

0:16:48.150,0:16:51.090
процессами на котором производится

0:16:50.190,0:16:53.940
выполнение

0:16:51.090,0:16:57.800
и вторым шагом уже вот-вот транслированы

0:16:53.940,0:17:00.630
you команду выполнить всю задачу про

0:16:57.800,0:17:02.520
преобразованию инструкций с байт-кода на

0:17:00.630,0:17:06.150
команда конкретного процессора

0:17:02.520,0:17:09.870
берёт на себя дал машины на данный

0:17:06.150,0:17:13.380
момент для всех компьютеров для которых

0:17:09.870,0:17:15.660
это имеет смысл ну там для очень слабого

0:17:13.380,0:17:18.120
компьютера там с маленьким числом памяти

0:17:15.660,0:17:20.069
с низкой частотой вообще писать на java

0:17:18.120,0:17:22.410
не имеет смысл ну это мы сегодня узнаем

0:17:20.069,0:17:25.199
почему в принципе для всех компьютер для

0:17:22.410,0:17:26.540
которых то разумно задача создания

0:17:25.199,0:17:28.940
одного машин уже решат

0:17:26.540,0:17:36.080
под windows под маркой подлинно в зале

0:17:28.940,0:17:38.180
машина уже здесь вот скажите пожалуйста

0:17:36.080,0:17:40.750
вот я рассказал изучать иную историю как

0:17:38.180,0:17:43.400
работает раз платформе снабжала

0:17:40.750,0:17:47.270
благодаря чему можем взять один и тот же

0:17:43.400,0:17:49.970
исполняемый файл на java и без каких-то

0:17:47.270,0:17:52.100
модификаций запустить его на разных

0:17:49.970,0:17:53.630
платформах с точки зрения

0:17:52.100,0:17:55.580
производительности напишите пожалуйста

0:17:53.630,0:17:58.120
че мы чем-то заплатили стала быстрее

0:17:55.580,0:18:01.990
медленнее осталось так же по трассе

0:17:58.120,0:18:01.990
ведь просто комментариях

0:18:41.059,0:18:44.450
да спасибо вот появился правильный ответ

0:18:42.830,0:18:46.370
конечно завладели временем исполнения

0:18:44.450,0:18:48.289
конечно стала медленно

0:18:46.370,0:18:52.070
все все ответы правильные ты

0:18:48.289,0:18:57.139
действительно если тут у нас программе

0:18:52.070,0:18:59.090
носи на каждую инструкцию базовая пока

0:18:57.139,0:19:01.429
один шаг выполнить то теперь на каждый

0:18:59.090,0:19:03.700
инструкции вас два шага 1 шага барнетт

0:19:01.429,0:19:11.720
виртуальная машина java

0:19:03.700,0:19:13.340
вот оно преобразует команду с байт-кода

0:19:11.720,0:19:15.980
of нативный код и потом про за

0:19:13.340,0:19:17.749
выполняется у нас получается что если в

0:19:15.980,0:19:19.850
первом варианте программы выполняются

0:19:17.749,0:19:22.519
сразу на процессоре то во втором

0:19:19.850,0:19:33.049
варианте получается что программа

0:19:22.519,0:19:34.429
выполняет программу документально

0:19:33.049,0:19:37.279
сколько мне известно жало ведьме

0:19:34.429,0:19:38.899
непременно полтора-два раза это такой

0:19:37.279,0:19:42.499
вопрос дискуссионный мы сейчас

0:19:38.899,0:19:46.429
постепенно начну рассказывать и будет

0:19:42.499,0:19:47.809
ясно что в принципе можно подобрать

0:19:46.429,0:19:52.419
такой специально сконструированный

0:19:47.809,0:19:55.490
пример что программы на java будет

0:19:52.419,0:19:56.690
быстрее программы на си но это отдельно

0:19:55.490,0:19:58.820
специально построен например

0:19:56.690,0:20:00.649
искусственные но вот если говорить в

0:19:58.820,0:20:02.539
среднем что если как бы депутация

0:20:00.649,0:20:05.240
искусственно построить очень быструю

0:20:02.539,0:20:09.679
программа просто программировать решая с

0:20:05.240,0:20:11.379
помощью языка свою задачу камеру игру

0:20:09.679,0:20:14.090
или создавая систему документооборота

0:20:11.379,0:20:19.159
или что то еще то конечно программа

0:20:14.090,0:20:20.559
будет мир не вот там слезает но пока мы

0:20:19.159,0:20:22.999
получили кроссплатформенность

0:20:20.559,0:20:25.789
возможность одну и туже прогрел парень

0:20:22.999,0:20:30.590
разных компьютерах без перекомпиляции

0:20:25.789,0:20:35.950
и другие дар . на сегодняшний день это

0:20:30.590,0:20:35.950
является не главной причиной выбора java

0:20:36.669,0:20:42.019
5 разбираться дальше это была главная

0:20:41.090,0:20:45.440
особенность

0:20:42.019,0:20:47.769
сейчас мы обсудим и другие особенности

0:20:45.440,0:20:49.900
языка java

0:20:47.769,0:20:53.260
чём была проблема

0:20:49.900,0:20:55.060
си плюс плюс вообще конечно можно было

0:20:53.260,0:21:00.400
писать очень быстрой программы который

0:20:55.060,0:21:05.620
очень эффективно использует процессор и

0:21:00.400,0:21:07.620
не уступают по эффективности программ

0:21:05.620,0:21:12.630
написано вручную на севере

0:21:07.620,0:21:18.930
вот но при этом программировать 8 тяжело

0:21:12.630,0:21:23.890
почему тяжело ну во-первых платой за

0:21:18.930,0:21:25.420
скорость является особенность риска

0:21:23.890,0:21:27.940
которая позволяет легко допустить ошибку

0:21:25.420,0:21:30.430
и долго и и потом искать во время

0:21:27.940,0:21:33.480
отладки что я имею ввиду

0:21:30.430,0:21:37.170
ну дело в том что все си плюс плюс

0:21:33.480,0:21:41.770
массив это просто напрямую транслируются

0:21:37.170,0:21:43.870
операция седана robots пончо и не

0:21:41.770,0:21:47.230
компилятор не вали на выполнение не

0:21:43.870,0:21:49.870
происходит никакого контроля затем не

0:21:47.230,0:21:51.580
вышли за пределы массива это очень

0:21:49.870,0:21:53.380
эффективно потому что у вас обращение к

0:21:51.580,0:21:55.900
чайке массива это практически 1-я

0:21:53.380,0:21:58.380
северная инструкция с другой стороны

0:21:55.900,0:22:02.110
если вы выходите за пределы массива

0:21:58.380,0:22:05.080
все + + или всем компилятором вода не

0:22:02.110,0:22:07.480
показывает и вы такую ошибку будете

0:22:05.080,0:22:08.650
очень долго искать потому что это бывает

0:22:07.480,0:22:10.690
define by heather

0:22:08.650,0:22:13.900
так как программа будет вести себя

0:22:10.690,0:22:16.990
зависит от того что в памяти находилось

0:22:13.900,0:22:18.700
до вашей программы как компилятор

0:22:16.990,0:22:21.580
операционной системы разобщили вашу

0:22:18.700,0:22:23.620
программу памяти и так далее возможно

0:22:21.580,0:22:26.860
метро запускаетесь работает выбор

0:22:23.620,0:22:28.570
запускаете программу не работает просто

0:22:26.860,0:22:31.450
смотри есть ошибка но на одном

0:22:28.570,0:22:33.220
компьютере в этой части был 0 где вышли

0:22:31.450,0:22:34.880
за пределом другой был к это значение

0:22:33.220,0:22:37.010
моя фотография

0:22:34.880,0:22:39.170
летом то можно может можно попасть

0:22:37.010,0:22:41.480
данной другой программы программа упадет

0:22:39.170,0:22:43.220
и так далее этот труд разводимые ошибки

0:22:41.480,0:22:47.410
при разных запуска будет разных атак в

0:22:43.220,0:22:50.030
этом проблема далее швы не так вообще

0:22:47.410,0:22:52.010
решили что окей мы

0:22:50.030,0:22:56.630
компьютеры постоянно развивается то есть

0:22:52.010,0:22:59.240
увеличивается частота и мы заплатим

0:22:56.630,0:23:01.160
производительностью за время работы

0:22:59.240,0:23:03.800
программистов про гранит

0:23:01.160,0:23:05.210
будет работать меньше жить ему станет

0:23:03.800,0:23:07.460
легче программу

0:23:05.210,0:23:09.890
стать быстрее но плата за это вы более

0:23:07.460,0:23:14.420
медленной программы вообще это очень

0:23:09.890,0:23:17.240
разумно размер потому что нельзя хотя

0:23:14.420,0:23:19.730
что все просто java говорят что это

0:23:17.240,0:23:22.100
языки jeunesse

0:23:19.730,0:23:24.820
язык общего назначения на нем можно 5

0:23:22.100,0:23:27.470
как бы все рисков есть ниши

0:23:24.820,0:23:30.910
если мы говорим ради этого списка вроде

0:23:27.470,0:23:32.810
приложениях управление ракетой или

0:23:30.910,0:23:36.530
компьютерной игрой нам с 3d графикой

0:23:32.810,0:23:41.300
которая сложно рассчитывать

0:23:36.530,0:23:44.030
или нейронные сети которые распознают

0:23:41.300,0:23:46.400
это все описано си плюс плюс но при этом

0:23:44.030,0:23:48.650
есть большое количество программ от

0:23:46.400,0:23:51.110
которых огромные крысы не требуется

0:23:48.650,0:23:53.720
гораздо важнее для не чтоб них было

0:23:51.110,0:23:57.260
меньше ошибок ну например банковские

0:23:53.720,0:23:59.990
системы в принципе когда вы работаете

0:23:57.260,0:24:01.790
там сайтом ну наверное отклик бросил

0:23:59.990,0:24:04.430
быть за три секунды там деньги

0:24:01.790,0:24:07.490
переводите но будет ли он за одну

0:24:04.430,0:24:09.080
секунду или задвину не так важно не

0:24:07.490,0:24:11.600
имеет смысл канада за этим лучше что

0:24:09.080,0:24:14.120
программа была надежный без ошибок

0:24:11.600,0:24:16.580
написали бы и быстрее сочным солидуса

0:24:14.120,0:24:18.380
значит подарок и меньше денег потому что

0:24:16.580,0:24:20.810
нужно с программистом водить зарплату

0:24:18.380,0:24:22.850
нужно платить если есть ошибки нужно

0:24:20.810,0:24:25.280
платить там саппорту который будет

0:24:22.850,0:24:27.740
как-то пользования все дела случае

0:24:25.280,0:24:32.930
ошибок и так далее есть большое

0:24:27.740,0:24:36.850
количество ниш в которых есть количество

0:24:32.930,0:24:36.850
ниш которые более башен

0:24:36.930,0:24:40.630
хотя как бы

0:24:38.470,0:24:43.600
языке другом на стыках пытаются как то

0:24:40.630,0:24:47.040
конкурировать но майдас написан на java

0:24:43.600,0:24:49.500
но в принципе вот на данный момент

0:24:47.040,0:24:53.560
смерти разные области

0:24:49.500,0:24:55.420
что сделали на java найджара на массив

0:24:53.560,0:24:59.140
это отдельный класс

0:24:55.420,0:25:01.540
то есть любое обращение элементу массива

0:24:59.140,0:25:06.040
это фактически вы за функций и внутри

0:25:01.540,0:25:10.440
этой функции есть проверка и эта

0:25:06.040,0:25:13.660
проверка если выходит за пределы массива

0:25:10.440,0:25:15.850
бросает xf жаль обработка ошибок

0:25:13.660,0:25:18.790
построена exception of через пару лекции

0:25:15.850,0:25:23.650
мы доберемся про детали этого но кто вы

0:25:18.790,0:25:25.630
получаете у вас никогда при работе с

0:25:23.650,0:25:27.520
массивом не будет отдыхает беседа

0:25:25.630,0:25:29.170
если вы вышли за пределы массива

0:25:27.520,0:25:31.300
программа гарантированного упадет

0:25:29.170,0:25:32.890
гарантированно сломается если все про

0:25:31.300,0:25:34.570
использовать один запустили работать

0:25:32.890,0:25:36.820
другой родитель не работает в общем

0:25:34.570,0:25:41.380
пойди разберись в какое в каком месте

0:25:36.820,0:25:42.910
это огромный honor я ошибся на java не

0:25:41.380,0:25:45.820
так если вы же загудела mozilla

0:25:42.910,0:25:48.610
стопроцентно программа падает обращение

0:25:45.820,0:25:51.010
качайте массива это не обращение к чайке

0:25:48.610,0:25:53.910
памяти это вызов функции которая

0:25:51.010,0:25:57.520
контролирует диапазоны

0:25:53.910,0:26:01.270
значит плюс и понятно то есть быстро

0:25:57.520,0:26:04.680
обнаруженные ошибки минусы конечно опять

0:26:01.270,0:26:10.060
производительность вот у меня есть цикл

0:26:04.680,0:26:13.360
по массиву и на каждый если носи на си

0:26:10.060,0:26:20.410
плюс плюс вот содержимое цикла это одна

0:26:13.360,0:26:23.700
инструкция то в на каждой итерации цикла

0:26:20.410,0:26:25.780
добавляется по проверке которая

0:26:23.700,0:26:27.799
контролирует диапазона я конечно

0:26:25.780,0:26:33.570
правильно стран

0:26:27.799,0:26:35.809
следующий пункт сборщик мусора все очень

0:26:33.570,0:26:39.630
широкие возможности потому

0:26:35.809,0:26:42.120
где будет размещена переменная можно бы

0:26:39.630,0:26:45.890
сделать глобальную переменную можно

0:26:42.120,0:26:48.990
сделать переменную на стыке можно

0:26:45.890,0:26:52.740
выделить переменную для ли ческой памяти

0:26:48.990,0:26:53.309
в хип при этом когда ты работаешь с

0:26:52.740,0:26:58.260
типом

0:26:53.309,0:26:58.710
у тебя это называется почему управление

0:26:58.260,0:27:02.630
памятью

0:26:58.710,0:27:05.040
то есть ты должен сам случае такси

0:27:02.630,0:27:08.179
инструкцию и функцию free вызывать

0:27:05.040,0:27:11.940
случае все плюс вызывать оператор диет

0:27:08.179,0:27:13.919
вот в моем примере обе ситуации ведут

0:27:11.940,0:27:19.530
утечки потому что и в первом втором

0:27:13.919,0:27:22.049
примере программист забыл что выделенный

0:27:19.530,0:27:25.410
но в первом случае объект в 1 мосин

0:27:22.049,0:27:27.900
стран случае объект опять же если то

0:27:25.410,0:27:30.299
грамм маленькая она запустилась делала

0:27:27.900,0:27:32.400
свою работу и закончила это не аккуратно

0:27:30.299,0:27:34.429
не страшно потому что просто как

0:27:32.400,0:27:37.290
загнанная в стену

0:27:34.429,0:27:41.850
завершает свою работу все выделенные ими

0:27:37.290,0:27:43.049
ресурсы освобождаются другое дело что мы

0:27:41.850,0:27:45.240
с вами обсуждаешь то есть когда мы

0:27:43.049,0:27:49.309
серверного типа которые должны работать

0:27:45.240,0:27:55.410
постоянно выбранном софт в банкомате или

0:27:49.309,0:27:58.890
программа управления ракетой или сервер

0:27:55.410,0:28:00.770
который например вам для вас генерировал

0:27:58.890,0:28:03.450
страничке вконтакте

0:28:00.770,0:28:05.669
все эти программы они один раз до

0:28:03.450,0:28:09.480
пустились и работает вечном цикле

0:28:05.669,0:28:11.040
ожидали там каких то действия

0:28:09.480,0:28:13.049
пользователя что на этим на идея

0:28:11.040,0:28:16.020
ответить ну там например программ поныне

0:28:13.049,0:28:19.600
ракеты на датчике какие то мере его

0:28:16.020,0:28:22.900
кругу зависимости от того что что там

0:28:19.600,0:28:24.580
смотря что говорит или земли шлют и что

0:28:22.900,0:28:28.020
датчики показывают какие-то воздействия

0:28:24.580,0:28:31.090
применяют ракетном двигателе включает

0:28:28.020,0:28:31.660
сайт постоянно в этом цикле программа

0:28:31.090,0:28:34.090
ожидает

0:28:31.660,0:28:36.640
запроса пришел ваш за броском скажем

0:28:34.090,0:28:39.160
покажи мне там чертова программа

0:28:36.640,0:28:40.870
генерирует ответ посылает вам и жду

0:28:39.160,0:28:44.910
следующего запросов эти программы не

0:28:40.870,0:28:46.750
завершаются утечка в такой программе

0:28:44.910,0:28:50.799
ведет большим проблемам

0:28:46.750,0:28:52.470
потому что постепенно у вас остается все

0:28:50.799,0:28:55.600
меньше свободной памяти

0:28:52.470,0:28:57.070
сначала берёт потому что программа стен

0:28:55.600,0:28:59.770
тормозить потому что посмотрел может

0:28:57.070,0:29:03.309
использовать swap файл как только начнет

0:28:59.770,0:29:04.570
не хватать с тем начнет данные корова на

0:29:03.309,0:29:07.020
табло не использовала из памяти

0:29:04.570,0:29:09.610
складывать на жесткий диск жесткий диск

0:29:07.020,0:29:11.620
ну как минимум 10 раз бедные чем

0:29:09.610,0:29:15.490
оперативная память на самом деле больше

0:29:11.620,0:29:17.620
вот собственно начал тормозить

0:29:15.490,0:29:20.190
тогда уже закончится вместо обведенная

0:29:17.620,0:29:22.690
тацу память на диске

0:29:20.190,0:29:24.909
программа завершит мы опять же вы

0:29:22.690,0:29:27.220
представьте у нас работает сервер и

0:29:24.909,0:29:28.690
1 день деле он падает и вам нужно

0:29:27.220,0:29:30.580
разобраться где там со внутри стало

0:29:28.690,0:29:36.640
огромной программы вы забыли выполнить

0:29:30.580,0:29:37.289
ее брата решили по-другому это синтаксис

0:29:36.640,0:29:42.130
java

0:29:37.289,0:29:44.950
где происходит деление памяти но похоже

0:29:42.130,0:29:49.539
на си плюс нос мы немножко поговорим о

0:29:44.950,0:29:53.140
нюансах но при этом инструкции оператора

0:29:49.539,0:29:56.400
делит в языке нету должен выделить

0:29:53.140,0:30:00.490
память с помощью надрать ранил

0:29:56.400,0:30:03.850
удивит вызывает недолго специально для

0:30:00.490,0:30:05.470
этого со старта java машины отключён

0:30:03.850,0:30:07.000
отдельный компонент к нам двоится

0:30:05.470,0:30:11.909
кабачка лектор или по русски

0:30:07.000,0:30:14.500
сборщик мусора задача сборщика мусора

0:30:11.909,0:30:20.100
отслеживать какими объектами вы

0:30:14.500,0:30:24.100
перестали пользоваться и и их удалять

0:30:20.100,0:30:25.929
если например у вас внутри ваших функции

0:30:24.100,0:30:28.600
не осталось ни одной ссылки на

0:30:25.929,0:30:29.549
существующие объекты в

0:30:28.600,0:30:32.639
внутри функции

0:30:29.549,0:30:35.549
создали объект помощью new и мы шли этой

0:30:32.639,0:30:38.070
функции ссылку на этот объект

0:30:35.549,0:30:39.919
никуда не передали значит после

0:30:38.070,0:30:42.110
окончания функции

0:30:39.919,0:30:44.639
больше эти объекты мне воспользоваться

0:30:42.110,0:30:48.960
он как больше не нужен вот

0:30:44.639,0:30:51.690
горбач коллег топический просыпается от

0:30:48.960,0:30:53.450
смогли все такие ссылки в памяти и

0:30:51.690,0:30:56.789
удаляют те которые больше не нужны

0:30:53.450,0:30:59.489
понятно что это праведность одной

0:30:56.789,0:31:02.249
стороны нам не нужно писать делить и

0:30:59.489,0:31:06.289
проблема утечки памяти отсутствует но

0:31:02.249,0:31:09.389
это ведет кому что программы

0:31:06.289,0:31:10.590
джаве среднем требует больше памяти

0:31:09.389,0:31:14.850
логан на си плюс плюс

0:31:10.590,0:31:16.679
почему потому что когда там еще бабочка

0:31:14.850,0:31:19.830
лектор проснется он работает не

0:31:16.679,0:31:22.980
постоянно просыпается героически когда

0:31:19.830,0:31:26.100
он танк решит что вот это конкретно

0:31:22.980,0:31:28.710
память больше не нужно все требует

0:31:26.100,0:31:31.259
какого-то времени и вот все это время

0:31:28.710,0:31:33.119
ненужные уже данные которые программисты

0:31:31.259,0:31:35.850
на си плюс ну послушал бы диляна не был

0:31:33.119,0:31:37.619
удалились потому что он сам только нужно

0:31:35.850,0:31:41.369
удалять а тут есть некий алгоритм

0:31:37.619,0:31:43.769
который запускается периодически еще как

0:31:41.369,0:31:44.519
бы не сразу а должен там что-то как-то

0:31:43.769,0:31:46.470
посчитать

0:31:44.519,0:31:48.570
что по этике и добавить больше не нужно

0:31:46.470,0:31:51.779
его надо удалить собственно именно

0:31:48.570,0:31:53.369
поэтому ну и понятно что с одной стороны

0:31:51.779,0:31:54.779
у тебя требуется больше поймете на

0:31:53.369,0:31:57.149
другой стороны еще иметь не работать

0:31:54.779,0:31:57.809
начинает потому что работает твоя

0:31:57.149,0:31:59.940
программа

0:31:57.809,0:32:01.590
еще какой-то момент проснулся и начал

0:31:59.940,0:32:03.989
ходить по памяти

0:32:01.590,0:32:05.399
считаю эти ссылки garbage collector

0:32:03.989,0:32:08.700
понятно что он тоже

0:32:05.399,0:32:11.159
отжирает ресурсы процесс просто может

0:32:08.700,0:32:14.519
сказать запустилась еще одна программа

0:32:11.159,0:32:17.149
которая конкурирует своей программой за

0:32:14.519,0:32:22.109
ресурсы процессора

0:32:17.149,0:32:24.480
то есть все что я рассказываю это мы

0:32:22.109,0:32:26.519
ценой облегчение в жизни программиста

0:32:24.480,0:32:29.110
чтобы было проще программировать мы

0:32:26.519,0:32:32.200
теряем производительность и теряем объем

0:32:29.110,0:32:35.500
памяти но опять же это очень разумный

0:32:32.200,0:32:37.960
компромисс потому что очень часто лучше

0:32:35.500,0:32:41.400
пусть программ будет надежно и у нее не

0:32:37.960,0:32:44.290
бывает утечек у него не бывает

0:32:41.400,0:32:45.929
падение поп воспроизводимых мы готовы за

0:32:44.290,0:32:49.690
это заплатить

0:32:45.929,0:32:52.630
скоростью о памяти мотор можем купить у

0:32:49.690,0:32:55.290
нас там не так и на дороге стоит вот

0:32:52.630,0:32:55.290
такие соображения

0:32:56.160,0:33:03.190
значит ну опять же конечно вот эти вот

0:33:00.040,0:33:06.669
принципиальные решения они ведут к

0:33:03.190,0:33:08.650
ухудшению производительности но конечно

0:33:06.669,0:33:10.350
инженер-разработчик компиляторов и java

0:33:08.650,0:33:13.090
машин

0:33:10.350,0:33:16.780
предпринимают все эти усилия чтобы даже

0:33:13.090,0:33:20.679
в таких условиях получить довольно

0:33:16.780,0:33:23.309
быстрой программы и я щас расскажу о

0:33:20.679,0:33:23.309
технологиях

0:33:24.480,0:33:30.309
которые придуманы того чтобы программа

0:33:28.030,0:33:31.000
трава ускорить и вот благодаря этим

0:33:30.309,0:33:34.780
технологиям

0:33:31.000,0:33:40.270
иногда для специально сконструированных

0:33:34.780,0:33:40.870
примеров получается сделать программу

0:33:40.270,0:33:42.610
ножами

0:33:40.870,0:33:46.049
ну и какой-то фрагмент быстрее чем

0:33:42.610,0:33:51.549
алогично фрагмент на си плюс плюс значит

0:33:46.049,0:33:53.530
смотрите у нас мы тогда с вами крат

0:33:51.549,0:33:56.200
отмечали говорить кладезь и плюс плюс

0:33:53.530,0:34:01.120
говорили что бывают интерпретатор байт

0:33:56.200,0:34:04.030
компиляторы что такой интерпретатор это

0:34:01.120,0:34:04.840
программа которая за разберет одну

0:34:04.030,0:34:09.129
инструкцию

0:34:04.840,0:34:12.490
ее выполнения что такое компилятор то

0:34:09.129,0:34:16.290
есть он у меня есть программа на языке

0:34:12.490,0:34:19.060
высокого уровня и компилятор должен

0:34:16.290,0:34:22.300
взять и сгенерировать оптимальный набор

0:34:19.060,0:34:24.909
инструкций он должен с языка высокого

0:34:22.300,0:34:27.840
уровня перевести на машинный язык при

0:34:24.909,0:34:30.340
этом он много раз проходит по программе

0:34:27.840,0:34:31.700
в каждый конкретный момент он сможет

0:34:30.340,0:34:33.409
только одно конкретное место

0:34:31.700,0:34:35.000
программе а может смотреть и на

0:34:33.409,0:34:36.649
инструкцию которая была другая

0:34:35.000,0:34:40.220
инструкцию было которая была после

0:34:36.649,0:34:42.169
ну например у вас программе сначала идет

0:34:40.220,0:34:44.899
инструкция сложения потом инструкции

0:34:42.169,0:34:47.540
умножения и когда ты знаешь что у этого

0:34:44.899,0:34:50.839
процессор есть одна северная инструкция

0:34:47.540,0:34:54.800
которая позволяет и сложение сделать и

0:34:50.839,0:35:00.770
умножение ну например там вот у вас в

0:34:54.800,0:35:07.339
программе написано а равно а + 1 а потом

0:35:00.770,0:35:09.470
написано там а равно а умножить на 3 вот

0:35:07.339,0:35:11.300
и компилятор знает мне что у вас в

0:35:09.470,0:35:14.690
процессор есть инструкция муп этот

0:35:11.300,0:35:16.490
которая сразу умножают и складывает и он

0:35:14.690,0:35:19.160
видишь то есть две такие инструкции

0:35:16.490,0:35:25.060
подряд и можно их там заменить на там

0:35:19.160,0:35:26.270
скажем там булып там a13 что то такое да

0:35:25.060,0:35:29.150
интерпретатор

0:35:26.270,0:35:32.089
о таких штук делать не может потому что

0:35:29.150,0:35:34.339
он зараз обрабатывает только одну

0:35:32.089,0:35:36.140
инструкцию торг мы до этого обсуждали

0:35:34.339,0:35:41.060
работать а у машина взяла одну

0:35:36.140,0:35:43.069
инструкцию транслировало в в нативный

0:35:41.060,0:35:44.569
код выполнила ну как бы тут вот для java

0:35:43.069,0:35:49.369
машина вот этот байт код является

0:35:44.569,0:35:51.770
аналогом исходного кода на языке си для

0:35:49.369,0:35:53.839
компилятора но компилятор

0:35:51.770,0:35:56.150
он за раз просмотреть много инструкции

0:35:53.839,0:35:57.290
смотрит на целый блок интерпретатор же

0:35:56.150,0:36:01.180
смотрел только на одну инструкцию

0:35:57.290,0:36:05.230
конечно так никого не устраивало и

0:36:01.180,0:36:09.400
хотели джаву добавить конечно

0:36:05.230,0:36:11.750
компиляцию и оптимизацию на самом деле

0:36:09.400,0:36:13.220
есть такая технология но она

0:36:11.750,0:36:17.060
используется современный зал шок который

0:36:13.220,0:36:18.380
называется jit это джастин тайм ну то

0:36:17.060,0:36:22.329
есть можно перевести

0:36:18.380,0:36:25.480
компиляция время исполнения и hotspot

0:36:22.329,0:36:28.730
hotspot как бы горячее место то есть

0:36:25.480,0:36:31.130
место которая чаще всего выполняется или

0:36:28.730,0:36:33.970
место которое требует максимально чтоб

0:36:31.130,0:36:36.349
остальных инструкция то есть java машина

0:36:33.970,0:36:40.010
изначально вашу программа начинает fans

0:36:36.349,0:36:41.900
режиме этапе татара но при этом оно

0:36:40.010,0:36:46.490
ведет статистику про выполняемый

0:36:41.900,0:36:49.250
методы внутрь функции и смотрит какие из

0:36:46.490,0:36:51.560
них выполняются чаще всего на какие из

0:36:49.250,0:36:54.230
них приходится основная работа с точки

0:36:51.560,0:36:56.540
зрения процесса и назад hotspot то есть

0:36:54.230,0:36:59.540
разные скины в программе так называемые

0:36:56.540,0:37:06.170
гарячие области области которые простым

0:36:59.540,0:37:07.820
вас чаще всего после этого начинает

0:37:06.170,0:37:11.950
работать кусок называется джек джек

0:37:07.820,0:37:15.950
компилятор он именно эти горячий области

0:37:11.950,0:37:19.810
компилирует то есть уже старается для

0:37:15.950,0:37:22.130
них не каждую инструкцию перевести в

0:37:19.810,0:37:24.830
байт-кода перевести в нативный код

0:37:22.130,0:37:27.590
а взять целый блок эту всю функцию

0:37:24.830,0:37:29.690
целиком и подобрать для него оптимальный

0:37:27.590,0:37:32.150
набор инструкций чтобы он как можно

0:37:29.690,0:37:37.460
быстрее выполнялся при этом конечно вот

0:37:32.150,0:37:41.480
он делает вещи ну типа которых я

0:37:37.460,0:37:45.080
рассказал что я хочу что вы понимали

0:37:41.480,0:37:47.210
такого рода вещи компилятор языка java

0:37:45.080,0:37:50.450
которые компилирует байт-код делать не

0:37:47.210,0:37:52.730
может потому что он компилирует

0:37:50.450,0:37:55.730
для java машины про возможности

0:37:52.730,0:37:58.790
процессора он не знает про возможно

0:37:55.730,0:38:00.770
знает только виртуальная машина java вот

0:37:58.790,0:38:03.500
и как бы получается что в программе

0:38:00.770,0:38:06.470
начала есть две компиляции 1 компиляция

0:38:03.500,0:38:08.360
это вы вызываете с командной строки там

0:38:06.470,0:38:11.360
или из модели g идея компиляции который

0:38:08.360,0:38:15.890
образует в байт-код и потом компиляции

0:38:11.360,0:38:20.420
время выполнения берутся наиболее часто

0:38:15.890,0:38:24.140
используемые функции и для них во время

0:38:20.420,0:38:27.260
выполнения компилятор внутри java машины

0:38:24.140,0:38:28.910
пытается подобрать оптимальный набор уже

0:38:27.260,0:38:32.410
процессорных команд как отделать

0:38:28.910,0:38:32.410
компиляторы закрасили си плюс плюс

0:38:32.710,0:38:39.580
скажите пожалуйста с точки зрения

0:38:35.960,0:38:42.800
информации у кого больше информации о

0:38:39.580,0:38:43.840
программе у компилятора языка си плюс

0:38:42.800,0:38:48.100
плюс

0:38:43.840,0:38:52.369
или у компилятора внутри java машины и

0:38:48.100,0:38:56.000
почему такой непростой вопрос но вдруг

0:38:52.369,0:38:56.000
рукава tobot идеи

0:39:56.280,0:40:01.320
да значит получится расшатывать ужава

0:39:59.130,0:40:04.220
потому что она знает значение некоторых

0:40:01.320,0:40:06.240
переменных и может оптимизировать код

0:40:04.220,0:40:08.220
применяют значения у тлей

0:40:06.240,0:40:12.090
это правильное здесь приведу некий

0:40:08.220,0:40:14.070
пример пример будет недостоверный все

0:40:12.090,0:40:18.900
раза немножко сложнее но этот пример

0:40:14.070,0:40:21.510
даст возможность понять о чем взять

0:40:18.900,0:40:23.130
почему компилятор языка java которые

0:40:21.510,0:40:25.290
внутри java машина может иногда трава

0:40:23.130,0:40:30.060
тут взгляд раза кассе посмотрите на др

0:40:25.290,0:40:32.960
за гасим он вот у вас например танк есть

0:40:30.060,0:40:32.960
вот такой код

0:41:01.800,0:41:04.939
[аплодисменты]

0:41:14.329,0:41:20.130
тут нет никакого особенного смысла

0:41:17.190,0:41:25.220
просто чтобы показать идею вот это

0:41:20.130,0:41:27.569
программой закиси когда компилятор

0:41:25.220,0:41:31.460
перевода в машинный код он делать это до

0:41:27.569,0:41:34.559
запуска программы пор не знает какое

0:41:31.460,0:41:37.710
значение идет пользователь и поэтому он

0:41:34.559,0:41:39.799
вот и вот эту проверку должен

0:41:37.710,0:41:42.660
преобразовать в какую-то

0:41:39.799,0:41:46.079
инструкцию ну так как кмп соборная

0:41:42.660,0:41:49.380
инструкция теперь у нас есть компилятор

0:41:46.079,0:41:52.680
на джаве у него точно такая же программа

0:41:49.380,0:41:53.480
но скомпилировать он ее будет в момент

0:41:52.680,0:41:58.380
выполнения

0:41:53.480,0:42:00.779
ну то есть например он компилирует вот

0:41:58.380,0:42:02.970
этот кусок который ниже в момент когда

0:42:00.779,0:42:08.990
значение а уже известно и например

0:42:02.970,0:42:11.460
пользователь ввёл n равное 5

0:42:08.990,0:42:14.819
если компиляции вот этого куска

0:42:11.460,0:42:16.559
проводить в этот момент то вот этот

0:42:14.819,0:42:21.000
кусок из программы можно вообще

0:42:16.559,0:42:24.390
выполнить выкинуть то есть ты точно

0:42:21.000,0:42:25.470
знаешь что пор никогда не выполнен в 6

0:42:24.390,0:42:29.670
пользователь ввёл

0:42:25.470,0:42:30.359
5 то вот здесь вот не когда они будет

0:42:29.670,0:42:32.039
больше десяти

0:42:30.359,0:42:33.750
то есть ты можешь просто взять и

0:42:32.039,0:42:35.940
выкинуть из цикла вот это вот одну

0:42:33.750,0:42:38.309
проверку которую компилятор языка

0:42:35.940,0:42:40.109
все для этого сталин а у тебя под это в

0:42:38.309,0:42:42.779
цикле на одну инструкцию меньше

0:42:40.109,0:42:45.930
еще раз это не просто подобный пример но

0:42:42.779,0:42:46.920
он поясняет что компилятор языка java

0:42:45.930,0:42:49.410
который находится внутри виртуальной

0:42:46.920,0:42:50.880
машины то что он называется джек джастин

0:42:49.410,0:42:53.700
тайм компиляция момента

0:42:50.880,0:42:56.819
мнение он обладает большей информацией и

0:42:53.700,0:43:00.779
поэтому может иногда получить более

0:42:56.819,0:43:04.200
лучший кот опять же это как бы редкие

0:43:00.779,0:43:05.309
случаи и все равно надо понимаешь что

0:43:04.200,0:43:07.500
программа на джаве

0:43:05.309,0:43:09.690
будет работать мельче программы на си си

0:43:07.500,0:43:23.660
плюс плюс и долблю мне за это не за

0:43:09.690,0:43:23.660
производительность окей так

0:43:25.500,0:43:34.890
какие есть еще особенности у джавы

0:43:27.870,0:43:38.010
значит смотрите когда за свою работу

0:43:34.890,0:43:41.160
берется компилятор языка си плюс плюс он

0:43:38.010,0:43:47.130
многократно ходит по вашей программе и

0:43:41.160,0:43:49.250
старается скрыть создать оптимальный

0:43:47.130,0:43:52.260
набор инструкций вам быстрее всего

0:43:49.250,0:43:56.220
исполнялось в результате программа очень

0:43:52.260,0:43:58.380
сильно меняется то есть получить из к

0:43:56.220,0:44:01.950
сенсорной программы назад программу на

0:43:58.380,0:44:03.570
оси очень сложно конечно например можно

0:44:01.950,0:44:04.290
делать решить следующую задачу она

0:44:03.570,0:44:06.690
несложная

0:44:04.290,0:44:11.070
вот например у вас где-то в программе

0:44:06.690,0:44:12.990
есть проверка серийного номера но что

0:44:11.070,0:44:16.610
программа воды сильно была куплена вот

0:44:12.990,0:44:19.290
не очень сложно взять двоичный код и

0:44:16.610,0:44:21.960
анализом его найти то место которое

0:44:19.290,0:44:24.330
соответствует одной этой проверки ну

0:44:21.960,0:44:26.910
например удачно в коде это место

0:44:24.330,0:44:32.630
перезаписать отменить проверку

0:44:26.910,0:44:35.730
это сделать реалистично один из способов

0:44:32.630,0:44:37.080
взлома программ то есть тем что можно

0:44:35.730,0:44:39.390
пользоваться там лицензионным

0:44:37.080,0:44:41.360
программным теперь он состоит в этом но

0:44:39.390,0:44:43.470
например если у вас есть некий алгоритм

0:44:41.360,0:44:45.300
который составляет вашим финальный

0:44:43.470,0:44:47.910
собственность торговать алгоритм анализа

0:44:45.300,0:44:49.620
днк для получение лекарств и вы не

0:44:47.910,0:44:53.880
хотите ванникова рассказывать то

0:44:49.620,0:44:56.130
восстановить по двоичному коду ваш

0:44:53.880,0:44:57.750
алгоритм это практически не реализуемая

0:44:56.130,0:44:59.370
задача очень сложно ну практически

0:44:57.750,0:45:01.050
невозможно потому что компилятор

0:44:59.370,0:45:06.090
программу носил очень сильно

0:45:01.050,0:45:08.910
перелопатить у джавы не так в джаве в

0:45:06.090,0:45:10.530
байт-код попадает очень много информации

0:45:08.910,0:45:13.440
об исходной программе

0:45:10.530,0:45:16.020
сохраняются имена функций сохраняются

0:45:13.440,0:45:17.880
имена классов сохраняется поля классом

0:45:16.020,0:45:20.180
единственно что исчезает это имена

0:45:17.880,0:45:24.000
локальных переменных

0:45:20.180,0:45:27.900
вот по такому байт-кода восстановить

0:45:24.000,0:45:31.230
кого программу очень реалистично это

0:45:27.900,0:45:35.570
реальное дело то есть были судебные

0:45:31.230,0:45:37.310
прецеденты когда одна фирма брала

0:45:35.570,0:45:40.610
двоичный код нам

0:45:37.310,0:45:42.890
а бойкот в другой первое где

0:45:40.610,0:45:44.900
компилировали программу получала

0:45:42.890,0:45:50.570
программы на java немножко зарабатывала

0:45:44.900,0:45:52.690
и продавал от своего имени и какие плюсы

0:45:50.570,0:45:57.250
за зачем это делается

0:45:52.690,0:45:57.250
зачем так много информации сохраняется

0:45:57.580,0:46:01.160
например если программе происходит

0:45:59.720,0:46:03.890
ошибка тот самый accusser

0:46:01.160,0:46:06.320
в джаве мы поговорим в этом подробно

0:46:03.890,0:46:09.040
позже вы на экране увидьте точное

0:46:06.320,0:46:11.450
описание того места где ошибка произошла

0:46:09.040,0:46:14.330
то есть вы не просто увидите что

0:46:11.450,0:46:16.400
случилась ошибка java омской ошибка

0:46:14.330,0:46:18.950
произошла в таком-то файле на такой-то

0:46:16.400,0:46:21.920
строчки внутри такой то функция это

0:46:18.950,0:46:23.630
возможно только потому что в байт-код

0:46:21.920,0:46:26.720
сходилось очень много зараза в исходной

0:46:23.630,0:46:29.480
программе все такого нет вы бы только

0:46:26.720,0:46:34.850
можете сами вручную в каждое сообщение

0:46:29.480,0:46:36.980
об ошибке вручную писать что это за

0:46:34.850,0:46:38.570
место где ошибка произошла это точно

0:46:36.980,0:46:40.700
муторно джори происходит автоматически

0:46:38.570,0:46:44.720
есть вы когда генерал генерируете

0:46:40.700,0:46:47.930
исключения вы не это вручную строчку не

0:46:44.720,0:46:50.270
добавляете но java машина эту заразу

0:46:47.930,0:46:52.910
может достать потому что в байт коде эта

0:46:50.270,0:46:54.950
информация хранится о том где мы где вот

0:46:52.910,0:46:56.780
текущие спал исполняемая инструкции на

0:46:54.950,0:46:59.890
которая выпала магазин находится на 3

0:46:56.780,0:47:02.360
каковой файла в тёплой функции так далее

0:46:59.890,0:47:06.350
это плюс и минус

0:47:02.360,0:47:08.030
я уже сказал то есть по байт-код у

0:47:06.350,0:47:08.740
реалистичного ставить исходный код на

0:47:08.030,0:47:11.540
java

0:47:08.740,0:47:15.940
ну ты снесли что это дело за пять минут

0:47:11.540,0:47:17.780
но в принципе если xi плюс плюс это

0:47:15.940,0:47:20.570
огромный сложится задача

0:47:17.780,0:47:22.760
то нажали тара личная задача и поэтому

0:47:20.570,0:47:23.870
для жару есть стали программы который

0:47:22.760,0:47:25.880
называется отпуска тары

0:47:23.870,0:47:28.730
ну как бы английский термин опускает

0:47:25.880,0:47:30.620
означает запутывать они работают

0:47:28.730,0:47:33.800
исходным кодом на джаве то есть прежде

0:47:30.620,0:47:35.960
чем отдать программу компилятору вы

0:47:33.800,0:47:39.830
отдаете программе опускаться которая

0:47:35.960,0:47:41.780
программу всяко меняет то есть она ваших

0:47:39.830,0:47:44.140
вы когда программируете принято там

0:47:41.780,0:47:46.900
именно функции имена классов давайте

0:47:44.140,0:47:47.890
частичное ну типа там сорт или монстр

0:47:46.900,0:47:49.750
или

0:47:47.890,0:47:51.910
но чтобы другой программист мог понять

0:47:49.750,0:47:55.420
что это вообще делает а опускать он

0:47:51.910,0:47:57.970
берет и там монстр тренирует vx файл

0:47:55.420,0:48:00.130
переименуют в y и так далее имена

0:47:57.970,0:48:02.050
переменных изменит в общем он пытается

0:48:00.130,0:48:05.080
всяко запутать исходную программу что по

0:48:02.050,0:48:09.520
ней было не разобраться вот эта

0:48:05.080,0:48:10.900
особенность байт-кода следующий

0:48:09.520,0:48:13.720
особенность над наготе к java

0:48:10.900,0:48:17.980
я уже неоднократно разных курсов поминал

0:48:13.720,0:48:20.380
что чем более молодой язык ну вот java

0:48:17.980,0:48:23.850
нам 90-е годы там все плюсую семидесятые

0:48:20.380,0:48:26.560
годы чем шире у него обычный а то до тех

0:48:23.850,0:48:29.880
то есть стандарт игротеку java

0:48:26.560,0:48:33.610
входят ну не только такие привычные вещи

0:48:29.880,0:48:35.590
типа там контейнеров алгоритмов но это

0:48:33.610,0:48:39.180
то что мы с вами на си плюс изучают он

0:48:35.590,0:48:41.830
листы хэш-таблицы

0:48:39.180,0:48:44.530
ходит для работ с файловой системой но

0:48:41.830,0:48:46.720
все плюс плюс работа с файловой системой

0:48:44.530,0:48:50.560
появилась только по моему стандарте

0:48:46.720,0:48:53.350
семнадцатого года 2017 года под по

0:48:50.560,0:48:55.390
работы с файловой системой что мы файл

0:48:53.350,0:48:59.080
можем читать и записать это это можно

0:48:55.390,0:49:01.990
было и в 70 году по на все придумали что

0:48:59.080,0:49:03.870
в стандарте языка стандарте библиотеки

0:49:01.990,0:49:06.670
появились команды

0:49:03.870,0:49:09.010
прочитать список файлов в директории

0:49:06.670,0:49:16.300
удали директор и создадите которые так

0:49:09.010,0:49:17.890
далее раньше не приноси до 2017 года вам

0:49:16.300,0:49:20.250
нужно было специально для тех которая

0:49:17.890,0:49:23.740
под каждый писал с тем была бы своя

0:49:20.250,0:49:26.140
djali вот уже в первой версии поскольку

0:49:23.740,0:49:29.860
они думали о кроссплатформенность ее

0:49:26.140,0:49:32.950
нужно чтобы все это работало подраться с

0:49:29.860,0:49:36.310
тем уже в транс для отёки была поддержка

0:49:32.950,0:49:38.050
файловой системы опять же изначально

0:49:36.310,0:49:40.300
была поддержка многопоточности то си

0:49:38.050,0:49:42.490
плюс плюс тоже накладываясь появилась

0:49:40.300,0:49:45.940
там каком-то четырнадцатом году штольню

0:49:42.490,0:49:48.160
вот потом графическая библиотека

0:49:45.940,0:49:50.200
все плюс плюс стандарт языка графический

0:49:48.160,0:49:53.320
язык до сих пор не входит джайда можете

0:49:50.200,0:49:55.450
написать программу графическим

0:49:53.320,0:49:58.660
интерфейсом которая будет работать

0:49:55.450,0:50:00.660
под основным песчаными системами но их

0:49:58.660,0:50:03.910
раз на практике будем этим заниматься

0:50:00.660,0:50:06.190
сетевое программирование то же самое на

0:50:03.910,0:50:08.860
си для тех уносит смесь до сих пор

0:50:06.190,0:50:11.890
сетевое программирование входит на djali

0:50:08.860,0:50:13.630
то есть нужно братьев что еще не входит

0:50:11.890,0:50:15.430
в наготе под каждую систему есть

0:50:13.630,0:50:16.900
библиотека . по-разному работают вам

0:50:15.430,0:50:18.190
нужно если таити программа дед

0:50:16.900,0:50:20.530
кроссплатформенность и плюс плюс вам

0:50:18.190,0:50:24.310
нужно предусматривать

0:50:20.530,0:50:26.920
интеграций ускользать библиотека java по

0:50:24.310,0:50:32.440
умолчанию все это из коробки вам

0:50:26.920,0:50:33.970
доступны ну работу минут что в 7 для си

0:50:32.440,0:50:36.490
плюс плюс есть всякие сторонние

0:50:33.970,0:50:38.650
библиотеки нестандартные направлять эту

0:50:36.490,0:50:44.050
каюте которая пытается от же задачу

0:50:38.650,0:50:46.300
решить но как бы вот чтобы быть решение

0:50:44.050,0:50:55.330
было сразу готова и беспроблемное от

0:50:46.300,0:50:58.990
конечного так ну тут написано что

0:50:55.330,0:51:01.090
текущая версия java 8 на слайде но с

0:50:58.990,0:51:04.840
момента преподавания этого курса java

0:51:01.090,0:51:07.450
сменился релиза цикл то есть если вы это

0:51:04.840,0:51:10.510
простым языком версии java стали

0:51:07.450,0:51:12.160
выпускать гораздо чаще чем раньше то

0:51:10.510,0:51:15.730
есть сейчас по моему версия дрова на

0:51:12.160,0:51:17.980
выходит раз толик 3-4 месяца в общем

0:51:15.730,0:51:24.810
текущая версия java который мне кажется

0:51:17.980,0:51:27.220
вышла там то ли пришла tulip вышла 20

0:51:24.810,0:51:29.260
могу продать им же мне кажется там то ли

0:51:27.220,0:51:31.420
15 февраля вышло .

0:51:29.260,0:51:38.500
21 формирует как сейчас будет вот версия

0:51:31.420,0:51:47.050
java будет 15 вот то есть текущая версия

0:51:38.500,0:51:50.470
языка такая есть если логических налоги

0:51:47.050,0:51:54.670
ваш похожую на джаву там все что я

0:51:50.470,0:51:56.590
говорил до этого это правда и для вот

0:51:54.670,0:51:58.750
этого языка сишарп который был придуман

0:51:56.590,0:52:01.660
если позже травы и в принципе изначально

0:51:58.750,0:52:02.820
был более передовым потому что язык

0:52:01.660,0:52:04.860
которого входят следующие

0:52:02.820,0:52:08.790
он учитывает ошибки которые были

0:52:04.860,0:52:10.650
предшественники но когда сишарп вы же он

0:52:08.790,0:52:13.020
был более передовым чертова но сейчас

0:52:10.650,0:52:15.270
как обычно происходит это путь к бегунку

0:52:13.020,0:52:18.080
reusch технологии и если что-то

0:52:15.270,0:52:20.670
появляется хорошее в одном языке и и там

0:52:18.080,0:52:22.020
эту особенность там через пару релизов

0:52:20.670,0:52:24.000
сразу реализуют другом языке дать

0:52:22.020,0:52:25.770
конкуренты друг у друга копируют

0:52:24.000,0:52:29.340
то есть принципе эти многие

0:52:25.770,0:52:32.570
конкурирующие сишарп аналог чего нет

0:52:29.340,0:52:36.750
фреймворк это аналог java машины

0:52:32.570,0:52:41.000
единственное отличие что особый есть

0:52:36.750,0:52:41.000
всякие попытки сделать

0:52:41.030,0:52:45.810
виртуальную машину для сишарпа

0:52:43.530,0:52:48.810
под другие операционные системы там

0:52:45.810,0:52:53.040
например там есть под linux версия но в

0:52:48.810,0:52:55.170
принципе особо это так буйно как джаве

0:52:53.040,0:52:56.460
не развивается все-таки если мы говорим

0:52:55.170,0:52:59.130
отжали тут скорее всего

0:52:56.460,0:53:00.540
кроссплатформенная разработка а на тяжа

0:52:59.130,0:53:01.020
и скорее всего эта разработка под

0:53:00.540,0:53:04.740
windows

0:53:01.020,0:53:07.170
хотя есть версии и по другие

0:53:04.740,0:53:10.100
операционные системы но это все-таки не

0:53:07.170,0:53:13.250
очень популярны что такое не mainstream

0:53:10.100,0:53:16.230
вот с точки зрения там доступа к памяти

0:53:13.250,0:53:19.110
контроля за пределы массива бабочка

0:53:16.230,0:53:21.870
лектора сефард это это аналог если вы

0:53:19.110,0:53:24.540
умеете программировать на сишарпе вы ну

0:53:21.870,0:53:26.730
там популистов книжку периоде на java из

0:53:24.540,0:53:30.330
java тоже может фиктивность шар ну вот

0:53:26.730,0:53:33.630
это были близки и технологии что еще

0:53:30.330,0:53:34.590
можно сказать под android программы тоже

0:53:33.630,0:53:38.880
пишут на джарван

0:53:34.590,0:53:41.000
там есть тонкость google угол немножко

0:53:38.880,0:53:44.010
другой байт код то есть если вы

0:53:41.000,0:53:47.610
программу скомпилировать джавой под

0:53:44.010,0:53:50.730
desktop вам ее перенести не

0:53:47.610,0:53:53.190
перекомпилировать под android мне

0:53:50.730,0:53:55.650
получится то есть на уровне исходного

0:53:53.190,0:53:58.980
кода все одинаковые а вот на уровне

0:53:55.650,0:54:00.570
двоичного кода не работает ну и конечно

0:53:58.980,0:54:03.000
графический близок по телефон немножко

0:54:00.570,0:54:05.160
другая потому что экран меньшего размера

0:54:03.000,0:54:06.440
вместо мышки палец и так далее но в

0:54:05.160,0:54:09.380
общем

0:54:06.440,0:54:13.819
если вы а свой язык java то есть путь в

0:54:09.380,0:54:16.790
android очень короткий если под ios

0:54:13.819,0:54:18.950
все-таки язык который там есть это все

0:54:16.790,0:54:23.900
таки ближе к себе плюс плюс у

0:54:18.950,0:54:28.310
вот опыте все то android java теперь ну

0:54:23.900,0:54:30.970
я уже говорил что java развивается как с

0:54:28.310,0:54:33.170
помощью комьюнити ну то есть там

0:54:30.970,0:54:35.810
добровольной ассоциации людей из разных

0:54:33.170,0:54:41.089
фирм и просто волонтеров и также ли

0:54:35.810,0:54:45.290
фирмы орков есть версии для машины от

0:54:41.089,0:54:45.740
oracal есть версии от комьюнити опыт же

0:54:45.290,0:54:47.990
т.к.

0:54:45.740,0:54:50.890
вот в принципе для нашего курса в

0:54:47.990,0:54:50.890
годится любая версия

0:54:51.790,0:55:01.700
так ну дальше уже пойдут я вот договорю

0:54:57.530,0:55:03.410
5 слайд будет 1 побольше дальше будет

0:55:01.700,0:55:06.829
таки технически особенность там где

0:55:03.410,0:55:09.890
скачать какие версии есть такое сейчас

0:55:06.829,0:55:16.280
закончил кусок про основные идеи которые

0:55:09.890,0:55:18.230
были заложены и джори и ну как бы чем мы

0:55:16.280,0:55:20.270
за это заплатили вашим обсуждение идеи

0:55:18.230,0:55:23.170
давай я сделал небольшую паузу может у

0:55:20.270,0:55:23.170
кого-то появились вопросы

0:55:30.570,0:55:32.600
а

0:55:45.630,0:55:53.940
да что еще можно сказать что в принципе

0:55:49.220,0:55:56.160
вот развитие java идет не только в том

0:55:53.940,0:55:59.299
направлении что добывая с новой

0:55:56.160,0:56:03.029
конструкции появляются и другие языки

0:55:59.299,0:56:05.579
которые тоже компилируются байт-код ну

0:56:03.029,0:56:08.700
наверное два самых популярных таких

0:56:05.579,0:56:10.859
языка это язык скала язык котлин потом

0:56:08.700,0:56:14.069
санкт-петербурге разрабатывается это

0:56:10.859,0:56:18.500
языки которые комбинируются в байт-код

0:56:14.069,0:56:20.819
тоже машины и идеологически они пытаются

0:56:18.500,0:56:22.920
стать лучше чем java пытаюсь что

0:56:20.819,0:56:26.630
программистом было проще программировать

0:56:22.920,0:56:26.630
такое дальнейшее развитие идей java

0:57:10.949,0:57:15.159
вопрос по льда питателем компилятор

0:57:13.329,0:57:25.949
однопроходные компиляторы

0:57:15.159,0:57:29.829
это изобретя тары или что то другое ну

0:57:25.949,0:57:33.789
знаете я не большой специалист и я

0:57:29.829,0:57:38.499
отвечу но с моей точки зрения все-таки

0:57:33.789,0:57:44.319
интерпретатор делает следующем берёт

0:57:38.499,0:57:48.929
одну инструкцию и ее транслирует въезду

0:57:44.319,0:57:54.249
в команду процессоры выполняет вот

0:57:48.929,0:57:57.299
компилятор он не выполняет не когда он

0:57:54.249,0:58:00.729
просто на выходе

0:57:57.299,0:58:03.969
генерирует код на другом языке ну то

0:58:00.729,0:58:06.209
есть например он там с языка высокого

0:58:03.969,0:58:06.209
уровня

0:58:07.709,0:58:14.109
генерирует программу у нас эндрю он

0:58:12.729,0:58:16.539
может сделать один проход может быть

0:58:14.109,0:58:18.639
может использовать несколько проходов но

0:58:16.539,0:58:22.349
при этом он во время своего прохода

0:58:18.639,0:58:27.789
может анализировать несколько инструкций

0:58:22.349,0:58:29.739
соседних вот и он не делать выполнения

0:58:27.789,0:58:32.529
это катар обычно он смотрит только на

0:58:29.739,0:58:36.069
одну инструкцию и тут же ее выполняет

0:58:32.529,0:58:38.979
при этом вот я думаю что возможно вот

0:58:36.069,0:58:43.149
если есть специалисты по компилятором

0:58:38.979,0:58:45.119
интерпретатор и много по четким

0:58:43.149,0:58:47.439
формулировками теперь можно посмотреть

0:58:45.119,0:58:49.659
возможно я ошибаюсь вот именно так

0:58:47.439,0:58:52.149
строго но вот с точки зрения практики

0:58:49.659,0:58:53.649
вот есть как я сказал еще раз интегратор

0:58:52.149,0:58:55.569
за разберу одну инструкцию тут же ее

0:58:53.649,0:58:57.400
выполняют в процессе для этого

0:58:55.569,0:58:59.650
выполнение делал преобразований осталось

0:58:57.400,0:59:02.020
другой компилятор мог рассмотреть

0:58:59.650,0:59:07.810
несколько соседних инструкций может одно

0:59:02.020,0:59:11.920
может несколько и просто преобразует в в

0:59:07.810,0:59:14.160
другой язык без выполнения вот ну если

0:59:11.920,0:59:15.340
картина была под вопрос кратко

0:59:14.160,0:59:19.060
интерпретатор

0:59:15.340,0:59:22.720
это не на прохладный компилятор

0:59:19.060,0:59:24.970
интерпретатор обычно он после трансляции

0:59:22.720,0:59:28.440
но тыс перевод снова языкам другой как

0:59:24.970,0:59:28.440
горит собственные выполняет сразу

0:59:41.550,0:59:48.450
но сразу скажу что точные формулировки

0:59:43.860,0:59:50.280
это не мой конек ну если конечно дело не

0:59:48.450,0:59:54.290
касается там чего-то математического

0:59:50.280,0:59:54.290
именно программирования

1:00:12.069,1:00:23.039
так давайте двигаться дальше значит если

1:00:19.920,1:00:27.099
скачивать себе загружать себе

1:00:23.039,1:00:30.130
дистрибутив джавы то надо помнить о

1:00:27.099,1:00:32.199
следующих понятиях есть понятие джулия

1:00:30.130,1:00:34.630
java runtime environment

1:00:32.199,1:00:38.769
если прямой пирог при вот это значит

1:00:34.630,1:00:39.369
окружении запуска java джильи нужно тем

1:00:38.769,1:00:42.779
кто

1:00:39.369,1:00:47.289
программы на java только запускает

1:00:42.779,1:00:49.839
джильи это виртуальная машина java

1:00:47.289,1:00:53.109
ну собственно это обычно называется java

1:00:49.839,1:00:55.299
игр или java эльф в линуксе и стандарной

1:00:53.109,1:00:58.900
библиотека то есть это тот набор к

1:00:55.299,1:01:01.209
дружин только для запуска программ вам

1:00:58.900,1:01:04.680
же нужен просто назвать языка java

1:01:01.209,1:01:08.979
development kit набор разработчика

1:01:04.680,1:01:12.099
джавы что у тебя включая джирайя ну то

1:01:08.979,1:01:15.609
есть то что надо для запуска java +

1:01:12.099,1:01:18.969
компилятор как бы говорят на жаргоне

1:01:15.609,1:01:20.920
java se или java куда сито java.com 5

1:01:18.969,1:01:22.690
стать исполняемая программа которая

1:01:20.920,1:01:26.319
является компилятор то есть она нужна

1:01:22.690,1:01:29.640
для разработчиков вот если кто-то

1:01:26.319,1:01:29.640
упоминает java ток

1:01:29.699,1:01:34.059
документация по джаве представлена вот в

1:01:32.380,1:01:34.479
таком формате то есть можно взять в

1:01:34.059,1:01:37.390
гугле

1:01:34.479,1:01:41.499
слова java долг и получить ночью попозже

1:01:37.390,1:01:42.819
мы посмотрим это стандартно ты [ __ ] и

1:01:41.499,1:01:44.949
докуда сказав для отёки

1:01:42.819,1:01:49.299
она бывает как он лайн так и можно

1:01:44.949,1:01:54.699
скачать себе zip-архив спор с васаби

1:01:49.299,1:01:56.589
отёки ну если вы вижу студию когда там

1:01:54.699,1:01:58.180
наживали справку и там или ходить на

1:01:56.589,1:02:01.299
хоть макросов там и казаков они часто

1:01:58.180,1:02:03.329
называется msdn такая огромный

1:02:01.299,1:02:07.869
справочник по стандартным для отёки

1:02:03.329,1:02:09.839
теперь изначально джаван было в трех

1:02:07.869,1:02:12.219
версиях что это значит это значит что

1:02:09.839,1:02:14.890
компилятор один и тот же язык один и тот

1:02:12.219,1:02:16.989
же просто разными осканов для теке то

1:02:14.890,1:02:18.609
что мы будем с вами вот в этом семестре

1:02:16.989,1:02:22.170
обсуждать это называется с

1:02:18.609,1:02:29.460
не давай съем стандарта ниши то есть это

1:02:22.170,1:02:33.519
базовая java структуры данных алгоритмы

1:02:29.460,1:02:36.940
работа с файлами многопоточность и так

1:02:33.519,1:02:41.440
далее была еще такая версия java микро

1:02:36.940,1:02:44.410
идише одно время это была библиотека

1:02:41.440,1:02:48.460
java для устроить менее воде вчем

1:02:44.410,1:02:51.670
компьютер ну а но одно время даже вот на

1:02:48.460,1:02:55.650
старых телефонах там типа науки вот под

1:02:51.670,1:02:58.349
них писали или java ильи вот или

1:02:55.650,1:03:01.390
для не пытались писать для каких-то

1:02:58.349,1:03:04.749
умных на микроволновых но в данный

1:03:01.390,1:03:08.769
момент они популярная сегодня существует

1:03:04.749,1:03:10.539
экзотическом видео вот и если речь о

1:03:08.769,1:03:13.690
написании на java для мобильных

1:03:10.539,1:03:16.779
устройств это android поджала местное

1:03:13.690,1:03:18.220
точки зрения практически не желая есть

1:03:16.779,1:03:24.210
еще java и и

1:03:18.220,1:03:28.359
enterprise идише это библиотека java для

1:03:24.210,1:03:31.769
написания сетевых программ ей мы

1:03:28.359,1:03:31.769
займемся в следующем семестре

1:03:32.339,1:03:36.519
с я будем знать в этом семестре м я

1:03:35.049,1:03:38.999
фактически мертва если вам нужно

1:03:36.519,1:03:44.380
мобильные устройства берите android и

1:03:38.999,1:03:45.839
это собственно сетевые программы сайты

1:03:44.380,1:03:51.279
абсолютно семестре

1:03:45.839,1:03:54.190
значит что еще можно сказать про жанну

1:03:51.279,1:03:56.849
синтаксисе подобное то есть все очень

1:03:54.190,1:04:01.509
просто будет переключиться на java

1:03:56.849,1:04:04.839
ну или си плюс плюс и программируют на

1:04:01.509,1:04:06.369
java в объектно-ориентированном стиле то

1:04:04.839,1:04:08.440
есть если на си плюс плюс могли так

1:04:06.369,1:04:10.900
просто нужно в стиле как носи итог

1:04:08.440,1:04:13.210
используя функции могли писать на

1:04:10.900,1:04:16.809
классах она где комбинировать оба

1:04:13.210,1:04:18.460
подхода то на джаве изначально

1:04:16.809,1:04:21.670
программирует глупость или

1:04:18.460,1:04:23.470
этот стиль является основным то есть

1:04:21.670,1:04:26.050
если вы сделаете всю свою огромную

1:04:23.470,1:04:28.450
программу виде одного класса в котором

1:04:26.050,1:04:29.410
нет сто пятьсот функций вас не поймут

1:04:28.450,1:04:32.470
это не стиль java

1:04:29.410,1:04:36.100
ну а просто функцию без класса да и

1:04:32.470,1:04:39.670
вообще нельзя написать кроме того в

1:04:36.100,1:04:43.090
джаве нет разделения на заголовочный

1:04:39.670,1:04:45.250
и файлы с классами то есть класс

1:04:43.090,1:04:45.880
описывается в одном файле совершением

1:04:45.250,1:04:52.810
java

1:04:45.880,1:04:55.870
ну мы посмотрим пример из исходных кодов

1:04:52.810,1:04:57.940
решения java у байт-кода то есть то что

1:04:55.870,1:05:00.430
компе она преобразуют расширения класс

1:04:57.940,1:05:04.320
если у вас есть hello world java когда

1:05:00.430,1:05:04.320
оно преобразует его в hello world class

1:05:05.520,1:05:11.440
есть соглашение о 100 имя класс должно

1:05:09.250,1:05:15.280
совпадать с именем файла в котором он

1:05:11.440,1:05:23.490
хранится но опять же что для java

1:05:15.280,1:05:23.490
известно что поскольку изначально java

1:05:24.060,1:05:30.450
вышли ошибки и создавала конкретная

1:05:27.370,1:05:36.210
фирма и она сразу выпустила

1:05:30.450,1:05:36.210
java коде нко меньше но то есть пишется

1:05:36.540,1:05:46.870
ходим конвент и то есть документ в

1:05:42.970,1:05:49.450
которой можно скачать и посмотреть то

1:05:46.870,1:05:53.380
есть там описано как на джаннет принято

1:05:49.450,1:05:55.150
программировать с точки зрения

1:05:53.380,1:05:59.470
оформления кода

1:05:55.150,1:06:03.100
но там какие имена файлов сейчас покажу

1:05:59.470,1:06:06.220
как это пример какие отступы как

1:06:03.100,1:06:08.380
разбивать длинные строчке где ставятся

1:06:06.220,1:06:11.500
скобки вы творите внимание открывающая

1:06:08.380,1:06:14.440
скобка закрывающая скобка ну и так далее

1:06:11.500,1:06:16.990
это вот там 20 страниц описано как

1:06:14.440,1:06:19.090
писать код чтобы вот считалось что это

1:06:16.990,1:06:21.730
хороший ход на на java

1:06:19.090,1:06:24.610
если на си плюс плюс такого общего

1:06:21.730,1:06:27.760
мнения нету просто собираются в начале

1:06:24.610,1:06:29.690
проекта люди и вот договариваются как

1:06:27.760,1:06:32.540
они будут не гутарить скобочках нибудь

1:06:29.690,1:06:33.440
эти пробелы или есть такие его же coding

1:06:32.540,1:06:36.290
гайдлайн

1:06:33.440,1:06:38.510
от разных известных фильм от гугла или

1:06:36.290,1:06:41.180
ещё от кого-то тут же но вот просто есть

1:06:38.510,1:06:44.300
единый документ которого в общем все

1:06:41.180,1:06:50.050
более-менее следуют как как переменные

1:06:44.300,1:06:53.890
описываются там ветер одна переменная на

1:06:50.050,1:06:57.730
строку то есть вот так более

1:06:53.890,1:07:00.140
предпочтение вот так более

1:06:57.730,1:07:04.280
вот так более предпочтительно чем вот

1:07:00.140,1:07:06.620
так ну и так далее в общем есть четкие

1:07:04.280,1:07:11.030
указания как как сделать ну собственно

1:07:06.620,1:07:14.270
тоже на практиках превратили будут у вас

1:07:11.030,1:07:18.370
вот тоже требовать чтобы программ были

1:07:14.270,1:07:22.450
похожи на то как его царь

1:07:18.370,1:07:22.450
конвенция программе на java

1:07:22.890,1:07:26.100
[музыка]

1:07:26.230,1:07:31.730
ну вот это соглашение тоже оттуда что

1:07:29.030,1:07:37.640
обычно если у вас вы на массе могли

1:07:31.730,1:07:41.840
написать там скажем май лап и хранить

1:07:37.640,1:07:45.290
там класс который как-нибудь называется

1:07:41.840,1:07:50.930
граф то тут нужно чтобы класс граф

1:07:45.290,1:07:54.920
хранился в классе граф java так первая

1:07:50.930,1:07:57.020
программа значит опять же наша задача

1:07:54.920,1:07:59.330
разобраться в течение на и на следующей

1:07:57.020,1:08:03.200
лекции мы в детских каждое слово здесь

1:07:59.330,1:08:06.290
понять но пока вот если выйдет

1:08:03.200,1:08:09.080
попробовать вам нужно вернуться там к

1:08:06.290,1:08:11.350
этому слайду скачать 7 лет гдк это все

1:08:09.080,1:08:11.350
бесплатно

1:08:19.009,1:08:29.910
вот первая ссылка все получиться и так

1:08:22.620,1:08:32.009
далее вот первая программа

1:08:29.910,1:08:34.880
то есть давайте внимание тут есть два

1:08:32.009,1:08:39.140
класса есть класс которая делает работу

1:08:34.880,1:08:41.730
есть класс допускающих ну опытный

1:08:39.140,1:08:46.920
человек как вы стразами этот есть

1:08:41.730,1:08:51.299
функция мы вот main получает параметр

1:08:46.920,1:08:55.380
командной строки вот создается вот этот

1:08:51.299,1:08:56.100
класс вот он один из вас блин сам

1:08:55.380,1:08:59.040
принтер

1:08:56.100,1:09:03.120
это вывод на экран с переводом строки

1:08:59.040,1:09:10.160
что-то выводит это класс но есть метод

1:09:03.120,1:09:13.740
вот здесь мы создается экземпляр класса

1:09:10.160,1:09:16.410
потом не вызывается метод ну то есть это

1:09:13.740,1:09:22.799
крыло word делают значит дочь написано

1:09:16.410,1:09:25.020
ja россия halo write а вот эта строчка и

1:09:22.799,1:09:27.120
потом я строчка java мы пишите

1:09:25.020,1:09:28.080
пожалуйста что делать . один лишь на

1:09:27.120,1:09:32.660
делая строчка 2

1:09:28.080,1:09:32.660
если вы запомнили из моего рассказа

1:10:14.490,1:10:19.830
да спасибо всю реальность вот это вызов

1:10:16.740,1:10:22.760
компилятора на всякий случай скажу что

1:10:19.830,1:10:25.620
первые три лабораторных работ и

1:10:22.760,1:10:26.190
вас будут просить использовать командную

1:10:25.620,1:10:28.890
строку

1:10:26.190,1:10:32.300
начиная с 3 лабораторной работы можно

1:10:28.890,1:10:34.910
пользоваться я люблю любой ядре

1:10:32.300,1:10:41.220
спасибо все ответы правильные

1:10:34.910,1:10:44.040
здесь это два java файла это комбезов

1:10:41.220,1:10:45.480
компилятора и результате получится 2

1:10:44.040,1:10:49.620
класс файлов байт-кода

1:10:45.480,1:10:52.490
а вот это запуск вызвать java машину

1:10:49.620,1:10:55.170
отдать ей class main джон машина

1:10:52.490,1:10:59.480
просканирует этот класс посмотрите на

1:10:55.170,1:10:59.480
функция main если случайно ждет запуску

1:11:02.660,1:11:09.800
так значит теперь по поводу это уже

1:11:07.380,1:11:12.270
близко 1 лапы

1:11:09.800,1:11:14.580
если говорить про чистый

1:11:12.270,1:11:16.710
объектно-ориентированный подход не знаю

1:11:14.580,1:11:20.030
насколько корректный перевод слова

1:11:16.710,1:11:25.950
чистый если бы я говорил по-английски я

1:11:20.030,1:11:30.240
бы использовал термин pr как бы чистый

1:11:25.950,1:11:35.900
не смысле что не грязный а слышать

1:11:30.240,1:11:40.320
чистый какая-то идея использована без

1:11:35.900,1:11:43.020
всяких уточнений применения практике

1:11:40.320,1:11:47.660
общем берется только одна голая идея без

1:11:43.020,1:11:51.030
примеси других всяких кострюков ну вот и

1:11:47.660,1:11:53.310
там подкручивание вот если мы говорим

1:11:51.030,1:11:56.340
про чистый объектно-ориентированный язык

1:11:53.310,1:11:58.560
это значит что в этой программе или в

1:11:56.340,1:12:01.700
этом языке не должно быть ничего кроме

1:11:58.560,1:12:04.500
объектов только классы и объекты

1:12:01.700,1:12:07.680
вот например если бы java был таким

1:12:04.500,1:12:12.500
языком тогда бы например им тоже было бы

1:12:07.680,1:12:14.970
классом если мне нужно было увеличить

1:12:12.500,1:12:15.770
значение на единичку я бы вызывал

1:12:14.970,1:12:19.130
функцию

1:12:15.770,1:12:21.790
инкремент если мне нужно было один int

1:12:19.130,1:12:25.550
прибавить другому я вызвал и функцию id

1:12:21.790,1:12:28.070
конечно так было бы совсем медленно

1:12:25.550,1:12:29.600
потому что любой вызов функции накладные

1:12:28.070,1:12:31.460
расходы но я думаю что вы помните

1:12:29.600,1:12:36.110
сложных курс это вызывает функцию

1:12:31.460,1:12:38.120
тебе нужно перейти на место в памяти где

1:12:36.110,1:12:41.180
расположены ил код все ее параметры

1:12:38.120,1:12:45.020
сложить на стек запомнить адрес возврата

1:12:41.180,1:12:48.230
начать выполнение в конце перейти на

1:12:45.020,1:12:50.390
адрес возврата на вызов каждый функций

1:12:48.230,1:12:52.930
ты тратишь добавили процентной операции

1:12:50.390,1:12:54.680
то есть если бы java был чисто

1:12:52.930,1:12:56.660
объектно-ориентированным языком не были

1:12:54.680,1:12:59.420
только бы объекта и работала бы еще

1:12:56.660,1:13:03.650
медленнее чем сейчас потому что вот то

1:12:59.420,1:13:06.370
что например на си бы там было бы l плюс

1:13:03.650,1:13:11.020
плюс это было бы там одна или две

1:13:06.370,1:13:12.230
основные функции разные команды то вызов

1:13:11.020,1:13:16.730
функции

1:13:12.230,1:13:21.340
это ну десяточек команд вот и поэтому

1:13:16.730,1:13:23.600
уже настолько или же решили не замедлять

1:13:21.340,1:13:25.700
java это не чистый

1:13:23.600,1:13:29.800
объектно-ориентированный язык а конечно

1:13:25.700,1:13:32.720
в нем есть и примитивные типы то есть

1:13:29.800,1:13:40.490
есть просто простые переменные которых

1:13:32.720,1:13:44.870
вам привыкли си плюс плюс вот есть набор

1:13:40.490,1:13:47.300
типов это все типы которые есть в java и

1:13:44.870,1:13:49.850
а не одни и те же на всех платформах

1:13:47.300,1:13:53.770
если помните когда-то я рассказывал что

1:13:49.850,1:13:56.390
для скорости ты или такое вот все

1:13:53.770,1:13:59.510
допущения си плюс плюс например in the

1:13:56.390,1:14:01.970
зависит от платформы то есть на одном

1:13:59.510,1:14:04.180
компьютере эндо ну так на слабом компе

1:14:01.970,1:14:06.350
drink может быть два байта на

1:14:04.180,1:14:08.840
современных компьютерах и может быть

1:14:06.350,1:14:12.740
четыре байта если вы написали программу

1:14:08.840,1:14:15.470
то это может создать не плохую шутку

1:14:12.740,1:14:19.130
написали программу которая рассчитывает

1:14:15.470,1:14:21.170
что в переменной можно хранить 22 а

1:14:19.130,1:14:24.350
потом вас по рампе компилирует под

1:14:21.170,1:14:27.080
компьютер в котором но он такой

1:14:24.350,1:14:28.730
портативный маленький и в нем и доски

1:14:27.080,1:14:31.910
переменные они два байта может только

1:14:28.730,1:14:34.940
два 16 ими штатив вас просто потеряется

1:14:31.910,1:14:38.990
часть значение которого хранить драве от

1:14:34.940,1:14:41.270
такого нету в джори вот есть эти типы и

1:14:38.990,1:14:44.120
они абсолютно одинаковые на любой

1:14:41.270,1:14:46.190
платформе где вы не запускаете на любом

1:14:44.120,1:14:50.840
процессор его персоной системе обрати

1:14:46.190,1:14:56.690
внимание что нету слова say нет и an

1:14:50.840,1:15:00.040
seiner все типы знаковые то есть есть

1:14:56.690,1:15:04.490
логический тип true force бульон есть

1:15:00.040,1:15:06.770
тип чар для хранения символов но тут

1:15:04.490,1:15:10.220
написано 2 байта и unicode явка этому

1:15:06.770,1:15:13.010
еще вернусь расскажу есть сила численные

1:15:10.220,1:15:14.140
типы buy черт и фланг есть тип с

1:15:13.010,1:15:22.630
плавающей точкой

1:15:14.140,1:15:28.280
так давайте значит сейчас будет перерыв

1:15:22.630,1:15:29.570
давайте продолжим в 21:20 2135 через

1:15:28.280,1:15:33.280
пятнадцать что можно было спокойно

1:15:29.570,1:15:36.650
отдохнуть вторая часть лекции будет

1:15:33.280,1:15:41.750
наверно попроще мы просто разберем там

1:15:36.650,1:15:43.550
чем и for отличается от аналогов

1:15:41.750,1:15:47.240
но там наследования всяким ножка

1:15:43.550,1:15:49.520
посмотрим мелочей которые отличают вот

1:15:47.240,1:15:51.710
ja ja vu от считаешь просто будет

1:15:49.520,1:15:56.230
наглядно разбирать язык каких-то идей и

1:15:51.710,1:16:00.500
когда нужно готовить и их не будет вот

1:15:56.230,1:16:04.670
если у кого какие вопросы я же вижу эту

1:16:00.500,1:16:11.260
трансляцию и telegram пришли просто

1:16:04.670,1:16:11.260
souls 3 марта начнется 2135

1:16:18.030,1:16:27.660
так опечатка ли здесь лак четыре байта

1:16:22.580,1:16:31.560
читала сомневался спасибо может быть

1:16:27.660,1:16:33.890
[музыка]

1:16:31.560,1:16:33.890
менялы

1:16:54.260,1:17:00.110
беспалова дичь на общество было бы

1:16:56.060,1:17:03.650
восемь конечно наверно это ошибка смысла

1:17:00.110,1:17:07.900
не было да спасибо титана это опечатка

1:17:03.650,1:17:07.900
конечно же сейчас мы ее исправим то есть

1:17:08.320,1:17:12.040
конечно 8

1:17:28.350,1:17:31.460
так но

1:17:34.150,1:17:36.330
муки

1:17:39.570,1:17:43.640
спасибо дане свёкла была опечатка

1:18:05.179,1:18:10.039
отдавайте прошу вас если что можно будет

1:18:08.269,1:18:13.989
вопрос задать в начале следующей лекции

1:18:10.039,1:18:13.989
которая будет часть транс минут

